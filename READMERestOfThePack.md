# John Hannah's Awesome JavaScript Frameworks

[_Return to Categories_](readme.md)


## Rest of the Pack


### [AppRun](https://github.com/yysun/apprun) - [Official Site](https://yysun.github.com/apprun)

[![GitHub last commit](https://img.shields.io/github/last-commit/yysun/apprun.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/yysun/apprun.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/yysun/apprun.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/yysun/apprun.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/yysun/apprun.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/yysun/apprun.svg?style=flat-square)]()

Authored by Yiyi Sun, AppRun in a lightweight (3KB) library that uses 
TypeScript as the development language and takes inspiration from Elm, 
style model-view-update architecture and event publication and 
subscription.


### [Binding.scala](https://github.com/ThoughtWorksInc/Binding.scala) - No Official Site

[![GitHub last commit](https://img.shields.io/github/last-commit/ThoughtWorksInc/Binding.scala.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/ThoughtWorksInc/Binding.scala.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/ThoughtWorksInc/Binding.scala.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/ThoughtWorksInc/Binding.scala.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/ThoughtWorksInc/Binding.scala.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/ThoughtWorksInc/Binding.scala.svg?style=flat-square)]()

Binding.scala is a one-way data-binding library written in Scala, 
although it targets both JavaScript and JVM. Binding.scala can be used 
as a reactive templating language in both web and desktop GUI 
development. It enables you use native XHTML literal syntax to create 
reactive DOM nodes, which are able to automatically change whenever the 
data source changes... Binding.scala has more features and less concepts 
than other reactive web frameworks like ReactJS.


### [Bobril](https://github.com/Bobris/Bobril) - [Official Site](http://bobril.com/)

[![GitHub last commit](https://img.shields.io/github/last-commit/Bobris/Bobril.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/Bobris/Bobril.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/Bobris/Bobril.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/Bobris/Bobril.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/Bobris/Bobril.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/Bobris/Bobril.svg?style=flat-square)]()

Bobril takes inspiration from React and Mithril. It is fast, low size 
framework with rendering based on Virtual DOM. The main focus is on 
speed and simplicity of code generation...Content and behavior of any 
page can be defined simply by composing JavaScript objects.


### [Choo](https://github.com/choojs/choo) - [Official Site](https://choo.io/)

[![GitHub last commit](https://img.shields.io/github/last-commit/choojs/choo.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/choojs/choo.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/choojs/choo.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/choojs/choo.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/choojs/choo.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/choojs/choo.svg?style=flat-square)]()

Choo is a functional library for building user interfaces. It's small 
(4KB) and supports server rendering. They believe frameworks should be 
disposable, and components recyclable. They don't want a web where 
walled gardens jealously compete with one another. By making the DOM 
the lowest common denominator, switching from one framework to another 
becomes frictionless.


### [Cycle.js](https://github.com/cyclejs/cyclejs) - [Official Site](https://cycle.js.org/)

[![GitHub last commit](https://img.shields.io/github/last-commit/cyclejs/cyclejs.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/cyclejs/cyclejs.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/cyclejs/cyclejs.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/cyclejs/cyclejs.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/cyclejs/cyclejs.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/cyclejs/cyclejs.svg?style=flat-square)]()

Billed as a "functional and reactive JavaScript framework for 
predictable code" Cycle.js is primarily the work of André Staltz. 
Cycle’s core abstraction is your application as a pure function main() 
where inputs are read effects (sources) from the external world and 
outputs (sinks) are write effects to affect the external world. 
These I/O effects in the external world are managed by drivers: plugins 
that handle DOM effects, HTTP effects, etc.


### [DIO](https://github.com/thysultan/dio.js) - [Official Site](https://dio.js.org/)

[![GitHub last commit](https://img.shields.io/github/last-commit/thysultan/dio.js.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/thysultan/dio.js.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/thysultan/dio.js.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/thysultan/dio.js.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/thysultan/dio.js.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/thysultan/dio.js.svg?style=flat-square)]()

DIO is a lightweight (7KB), declarative UI library that offers an 
alternative to React. There a lot of small details that give DIO its 
edge that don't realy touch on new API's but rather on creating a 
larger surface area of what React already supports and adding to this.


### [Dojo](https://github.com/dojo/meta) - [Official Site](https://dojo.io/)

[![GitHub last commit](https://img.shields.io/github/last-commit/dojo/meta.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/dojo/meta.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/dojo/meta.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/dojo/meta.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/dojo/meta.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/dojo/meta.svg?style=flat-square)]()

One of the important principles behind [Dojo](https://dojo.io/) is
accessibility, which makes me think it's a potential candidate for
projects in government and higher education, where there are often
stringent compliance requirements. Dojo 2 is grounded in the belief that
accessibility is as important online as it is in our physical
environments, and architects of both share a similar responsibility to
provide access to all. Internationalization, or i18n, is the process of
decoupling an application from a particular language or culture, and is
a major requirement of most enterprise applications.


### [Domvm](https://github.com/leeoniya/domvm) - [Official Site](http://leeoniya.github.io/domvm/)

[![GitHub last commit](https://img.shields.io/github/last-commit/leeoniya/domvm.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/leeoniya/domvm.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/leeoniya/domvm.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/leeoniya/domvm.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/leeoniya/domvm.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/leeoniya/domvm.svg?style=flat-square)]()

[Domvm](http://leeoniya.github.io/domvm/) is a, "thin, fast,
dependency-free vdom view layer". Like Vue, it can be used as a jQuery
replacement. Similar to React, it leaves concerns beyond views to other
libraries (but provides a good list of options). domvm is a flexible,
pure-js view layer for building high performance web applications. Like
jQuery, it'll happily fit into any existing codebase without introducing
new tooling or requiring major architectural changes...As a view layer,
domvm does not include some things you would find in a larger framework.
This gives you the freedom to choose libs you already know or prefer for
common tasks. domvm provides a small, common surface for integration of
routers, streams and immutable libs.


### [DoneJS](https://github.com/dvajs/dva) - No Official Site

[![GitHub last commit](https://img.shields.io/github/last-commit/dvajs/dva.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/dvajs/dva.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/dvajs/dva.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/dvajs/dva.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/dvajs/dva.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/dvajs/dva.svg?style=flat-square)]()

[DoneJS](https://github.com/dvajs/dva) is a successor to JavaScriptMVC,
which was first released in 2008. DoneJS offers everything you need to
build a modern web app. It comes with a module loader, build system,
MVVM utilities, full testing layer, documentation generator, server side
rendering utilities, a data layer, and more. Its completeness is itself
a feature.


### [Etch](https://github.com/atom/etch) - No Official Site

[![GitHub last commit](https://img.shields.io/github/last-commit/atom/etch.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/atom/etch.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/atom/etch.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/atom/etch.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/atom/etch.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/atom/etch.svg?style=flat-square)]()

Although [Etch](https://github.com/atom/etch) can be used for front end
web applications, its target usage is in Atom packages and the Electron
desktop framework. Etch is a library for writing HTML-based user
interface components that provides the convenience of a virtual DOM,
while at the same time striving to be minimal, interoperable, and
explicit. Etch can be used anywhere, but it was specifically designed
with Atom packages and Electron applications in mind. 


### [Gruu](https://github.com/MarekLabuz/gruu) - [Official Site](https://gruujs.com/)

[![GitHub last commit](https://img.shields.io/github/last-commit/MarekLabuz/gruu.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/MarekLabuz/gruu.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/MarekLabuz/gruu.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/MarekLabuz/gruu.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/MarekLabuz/gruu.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/MarekLabuz/gruu.svg?style=flat-square)]()

[Gruu](https://gruujs.com/) is a relatively new framework by Marek
Łabuz. I believe that none of the existing libraries is perfect. Each
time a new library/framework is created, some new idea is revealed. No
matter if the new library is good or bad. It always brings something
unique that is valuable. Many frontend libraries rely on a render
function that is called each time something changes, no matter what the
change affects. It leads to unnecessary renders of the parts of the
application that has not changed, but still we have to check it because
we don't know for sure... Gruu gets rid of a render function. Instead,
it renders only once at the beginning, then it changes only this parts
of the view that have actually changed without rendering whole
components.


### [Glimmer](https://github.com/glimmerjs/glimmer.js) - [Official Site](https://glimmerjs.com/)

[![GitHub last commit](https://img.shields.io/github/last-commit/glimmerjs/glimmer.js.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/glimmerjs/glimmer.js.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/glimmerjs/glimmer.js.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/glimmerjs/glimmer.js.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/glimmerjs/glimmer.js.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/glimmerjs/glimmer.js.svg?style=flat-square)]()

[Glimmer](https://glimmerjs.com/) is part of the Ember ecosystem and
even uses the Ember CLI to manage projects. As mentioned when discussing
Ember, it is a large framework. Glimmer provides Ember developers with a
lighter weight option for building single page apps. If needed, Glimmer
components can be dropped directly into Ember without a problem. 


### [Hyperapp](https://github.com/hyperapp/hyperapp) - [Official Site](https://hyperapp.js.org/)

[![GitHub last commit](https://img.shields.io/github/last-commit/hyperapp/hyperapp.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/hyperapp/hyperapp.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/hyperapp/hyperapp.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/hyperapp/hyperapp.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/hyperapp/hyperapp.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/hyperapp/hyperapp.svg?style=flat-square)]()

Coming in at a very slender 1KB, [Hyperapp](https://hyperapp.js.org/) is
a library with a minimalist API. It does, however, support server
rendering. It is a JavaScript library for building web applications.
Hyperapp was born out of the attempt to do more with less. We have
aggressively minimized the concepts you need to understand while
remaining on par with what other frameworks can do. Hyperapp's design is
inspired by The Elm Architecture. Create scalable browser-based
applications using a functional paradigm. The twist is you don't have to
learn a new language. Out of the box, Hyperapp combines state management
with a VDOM engine that supports keyed updates & lifecycle events ---
all with no dependencies.


### [Hyperdom](https://github.com/featurist/hyperdom) - No Official Site

[![GitHub last commit](https://img.shields.io/github/last-commit/featurist/hyperdom.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/featurist/hyperdom.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/featurist/hyperdom.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/featurist/hyperdom.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/featurist/hyperdom.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/featurist/hyperdom.svg?style=flat-square)]()

Formerly named, Plastiq,
[Hyperdom](https://github.com/featurist/hyperdom), is a "fast, feature
rich virtual-dom framework for building dynamic browser applications." 
Hyperdom applications are made of regular JavaScript objects that
represent application state with render() methods that define how that
state is represented in HTML. Hyperdom supports a simple
event-update-render cycle, promises for asynchronous operations, JSX,
non-JSX, client-side routing, SVG, two-way data binding, and optimises
for performance, developer usability and simplicity of application
architecture.


### [hyperHTML](https://github.com/WebReflection/hyperHTML) - [Official Site](https://viperhtml.js.org/)

[![GitHub last commit](https://img.shields.io/github/last-commit/WebReflection/hyperHTML.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/WebReflection/hyperHTML.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/WebReflection/hyperHTML.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/WebReflection/hyperHTML.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/WebReflection/hyperHTML.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/WebReflection/hyperHTML.svg?style=flat-square)]()

Framework agnostic, [hyperHTML](https://viperhtml.js.org/) was created
to, "simplify DOM performance best practices... is 100% ECMAScript
compliant and it weighs in at less than 4Kb". It's nothing more than a
function, that works bound with DOM nodes and fragments as context. You
bind your target node once, or even more if you don't care, and you
render the same template literals over and over simply passing new data.


### [Ivi](https://github.com/ivijs/ivi) - No Official Site

[![GitHub last commit](https://img.shields.io/github/last-commit/ivijs/ivi.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/ivijs/ivi.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/ivijs/ivi.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/ivijs/ivi.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/ivijs/ivi.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/ivijs/ivi.svg?style=flat-square)]()

It seems that nowadays many people in javascript community were
brainwashed that small library size is a synonym to fast performance and
simple implementation. In reality it usually means that library is using
different tricks to reduce code size by using inappropriate data
structures (slower performance), initializing data structures at runtime
(slower bootstrap performance), reusing code for many different data
types (slower performance), etc. Library size in ivi library is at the
bottom on the list of priorities: Correctness, Consistency / Predictable
Behavior, Performance / Developer Experience and Library Size.


### [Knockout](https://github.com/knockout/knockout) - [Official Site](http://knockoutjs.com/)

[![GitHub last commit](https://img.shields.io/github/last-commit/knockout/knockout.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/knockout/knockout.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/knockout/knockout.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/knockout/knockout.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/knockout/knockout.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/knockout/knockout.svg?style=flat-square)]()

Using the MVVM pattern, [Knockout](http://knockoutjs.com/) is a library
that has been around for a while. Knockout is a JavaScript MVVM (a
modern variant of MVC) library that makes it easier to create rich,
desktop-like user interfaces with JavaScript and HTML. It uses observers
to make your UI automatically stay in sync with an underlying data
model, along with a powerful and extensible set of declarative bindings
to enable productive development.


### [Maquette](https://github.com/AFASSoftware/maquette) - [Official Site](https://maquettejs.org/)

[![GitHub last commit](https://img.shields.io/github/last-commit/AFASSoftware/maquette.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/AFASSoftware/maquette.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/AFASSoftware/maquette.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/AFASSoftware/maquette.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/AFASSoftware/maquette.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/AFASSoftware/maquette.svg?style=flat-square)]()

[Maquette](https://maquettejs.org/) is a lightweight (3KB) library
inspired by React, Mithril and Mercury. Maquette is a virtual DOM
implementation that excels in both speed and simplicity. It solves the
problem of keeping the user interface in sync with underlying data.
Maquette allows you to specify the UI using plain Javascript. This makes
maquette easy to learn, easy to debug and easy to deploy. Maquette is
very unopionated by design, making integration with other frameworks and
libraries as painless as possible.


### [Marko](https://github.com/marko-js/marko) - [Official Site](https://markojs.com/)

[![GitHub last commit](https://img.shields.io/github/last-commit/marko-js/marko.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/marko-js/marko.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/marko-js/marko.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/marko-js/marko.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/marko-js/marko.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/marko-js/marko.svg?style=flat-square)]()

A product of eBay Open Source, [Marko](https://markojs.com/) is a
reactive front end framework that emphasizes UI performance. Similar to
Vue, you can use single file components that include component logic,
template and CSS. While many of the features in Marko were inspired by
React, Marko and React offer very different usability and performance
characteristics. Marko was designed to avoid almost all boilerplate and
is more closely aligned with HTML. In almost all cases, a Marko UI
component will require less lines of code than its React JSX equivalent
while maintaining readability and allowing the same expressiveness as
JSX.


### [Mithril](https://github.com/MithrilJS/mithril.js) - [Official Site](https://mithril.js.org/)

[![GitHub last commit](https://img.shields.io/github/last-commit/MithrilJS/mithril.js.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/MithrilJS/mithril.js.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/MithrilJS/mithril.js.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/MithrilJS/mithril.js.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/MithrilJS/mithril.js.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/MithrilJS/mithril.js.svg?style=flat-square)]()

[Mithril](https://mithril.js.org/) is a lighweight framework. Unlike
React, it incudes functionality for routing, XHR and state management.
Why use Mithril? In one sentence: because Mithril is pragmatic. This 10
minute guide is a good example: that's how long it takes to learn
components, XHR and routing - and that's just about the right amount of
knowledge needed to build useful applications. Mithril is all about
getting meaningful work done efficiently. Doing file uploads? The docs
show you how. Authentication? Documented too. Exit animations? You got
it. No extra libraries, no magic.


### [Moon](https://github.com/kbrsh/moon) - [Official Site](http://moonjs.ga/)

[![GitHub last commit](https://img.shields.io/github/last-commit/kbrsh/moon.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/kbrsh/moon.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/kbrsh/moon.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/kbrsh/moon.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/kbrsh/moon.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/kbrsh/moon.svg?style=flat-square)]()

A small (7KB) library, [Moon](http://moonjs.ga/) positions itself as an
alternative to React, Vue and Mithril. Moon is a minimal, blazing fast
library for building user interfaces. It combines the positive aspects
of popular libraries into one small package. It's super lightweight, and
includes advanced optimizations to ensure fast render times. The API is
small and intuitive, while still remaining powerful. Moon is compatible
with IE9+. Moon aims to combine the best parts of best known libraries
into a single, lightweight package, while providing improved
performance.


### [Nerv](https://github.com/NervJS/nerv) - [Official Site](https://nerv.aotu.io/)

[![GitHub last commit](https://img.shields.io/github/last-commit/NervJS/nerv.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/NervJS/nerv.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/NervJS/nerv.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/NervJS/nerv.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/NervJS/nerv.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/NervJS/nerv.svg?style=flat-square)]()

[Nerv](https://nerv.aotu.io/) is a new framework out of China. It bills
itself as a, "blazing fast React alternative, compatible with IE8 and
React 16." In fact, you can convert a React app to Nerv simply by adding
an alias in your webpack config. All of that and a library size of 4.4
KB. Because it is so new and makes claims of superior performance vs
React --- some members of the React community asked for clarification on
those claims, as well as more information about Nerv. 


### [NX](https://github.com/nx-js/framework) - [Official Site](https://www.nx-framework.com/)

[![GitHub last commit](https://img.shields.io/github/last-commit/nx-js/framework.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/nx-js/framework.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/nx-js/framework.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/nx-js/framework.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/nx-js/framework.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/nx-js/framework.svg?style=flat-square)]()

NX is the work of Bertalan Miklos, JavaScript engineer at RisingStack.
NX is a modular front-end framework - built with ES6 and Web Components.
The building blocks of NX are the core, the middlewares, the components
and the utilities. These are all hosted in separate GitHub repos and npm
packages. The NX core is a tiny library, responsible for one thing only.
It allows you to create dumb components and to augment them with
middlewares. A component executes its middlewares when it is attached to
the DOM and it gains all the extra functionalities from them.  


### [petit-dom](https://github.com/yelouafi/petit-dom) - No Official Site

[![GitHub last commit](https://img.shields.io/github/last-commit/yelouafi/petit-dom.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/yelouafi/petit-dom.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/yelouafi/petit-dom.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/yelouafi/petit-dom.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/yelouafi/petit-dom.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/yelouafi/petit-dom.svg?style=flat-square)]()

Authored by Yassine Elouafi and one of the fastest in performance
benchmarks, [petit-dom](https://github.com/yelouafi/petit-dom) takes a
minimalist approach: Diff algroithm is based on pre-optimizations
described at https://neil.fraser.name/writing/diff/ and the algorithm
presented in the paper "An O(ND) Difference Algorithm and Its
Variations. There is also an excellent article which explains how the
algorithm works. The article includes a GUI application to play with the
algorithm.


### [Pux](https://github.com/alexmingoia/purescript-pux) - [Official Site](http://purescript-pux.org/)

[![GitHub last commit](https://img.shields.io/github/last-commit/alexmingoia/purescript-pux.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/alexmingoia/purescript-pux.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/alexmingoia/purescript-pux.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/alexmingoia/purescript-pux.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/alexmingoia/purescript-pux.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/alexmingoia/purescript-pux.svg?style=flat-square)]()

[Pux](http://purescript-pux.org/) is a framework that uses
[PureScript](http://www.purescript.org/), a strongly-typed, functional
programming language that complies to JavaScript. There are currently
problems with performance: The slow performance arises from translating
Pux's (smolder) virtual DOM to React's virtual DOM. The goal is to write
a purescript virtual DOM module for smolder, which would avoid that
translation step and could be optimized for a monadic datastructure. I
suspect this would achieve performance on par with Halogen.


### [Ractive.js](https://github.com/ractivejs/ractive) - [Official Site](https://ractive.js.org/)

[![GitHub last commit](https://img.shields.io/github/last-commit/ractivejs/ractive.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/ractivejs/ractive.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/ractivejs/ractive.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/ractivejs/ractive.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/ractivejs/ractive.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/ractivejs/ractive.svg?style=flat-square)]()

Originally created for use on the Guardian website,
[Ractive](https://ractive.js.org/) is a reactive, template-driven UI
library. Unlike other frameworks, Ractive works for you, not the other
way around. It doesn't have an opinion about the other tools you want to
use with it. It also adapts to the approach you want to take. You're not
locked-in to a framework-specific way of thinking. Should you hate one
of your tools for some reason, you can easily swap it out for another
and move on with life.


### [RE:DOM](https://github.com/redom/redom) - [Official Site](https://redom.js.org/)

[![GitHub last commit](https://img.shields.io/github/last-commit/redom/redom.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/redom/redom.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/redom/redom.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/redom/redom.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/redom/redom.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/redom/redom.svg?style=flat-square)]()

Authored by Juha Lindstedt, [RE:DOM](https://redom.js.org/) is a small
(2KB) and fast UI library. In fact, it's one of the best performers in
the latest benchmarks. RE:DOM is a tiny (2 KB) DOM library by Juha
Lindstedt and contributors, which adds useful helpers to create DOM
elements and keeping them in sync with the data. Because RE:DOM is so
close to the metal and doesn't use virtual dom, it's actually faster and
uses less memory than almost all virtual dom based libraries, including
React (benchmark).


### [react-lite](https://github.com/Lucifier129/react-lite) - No Official Site

[![GitHub last commit](https://img.shields.io/github/last-commit/Lucifier129/react-lite.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/Lucifier129/react-lite.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/Lucifier129/react-lite.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/Lucifier129/react-lite.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/Lucifier129/react-lite.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/Lucifier129/react-lite.svg?style=flat-square)]()

Aiming to be a lighter-weight version of React,
[react-lite](https://github.com/Lucifier129/react-lite), is an
"implementation of React that optimizes for small script size". 
React-lite supports the core APIs of React, such as Virtual DOM,
intended as a drop-in replacement for React, when you don't need
server-side rendering in browser(no ReactDOM.renderToString &
ReactDOM.renderToStaticMarkup).


### [Ultradom](https://github.com/jorgebucaran/ultradom) - No Official Site

[![GitHub last commit](https://img.shields.io/github/last-commit/jorgebucaran/ultradom.svg?style=flat-square)]()
[![GitHub tag](https://img.shields.io/github/tag/jorgebucaran/ultradom.svg?style=flat-square)]()
[![GitHub watchers](https://img.shields.io/github/watchers/jorgebucaran/ultradom.svg?style=flat-square)]()
[![GitHub stars](https://img.shields.io/github/stars/jorgebucaran/ultradom.svg?style=flat-square)]()
[![GitHub forks](https://img.shields.io/github/forks/jorgebucaran/ultradom.svg?style=flat-square)]()
[![GitHub issues](https://img.shields.io/github/issues/jorgebucaran/ultradom.svg?style=flat-square)]()

[Ultradom](https://github.com/jorgebucaran/ultradom) is interesting in
that it's authored by the same guy behind [Hyperapp](#hyperapp), Jorge
Bucaran. Described as a, "1 KB VDOM builder and patch function",
Ultradom is a tool that can be used to build your own framework.
Ultradom supports keyed updates & lifecycle events --- all with no
dependencies. Mix it with your favorite state management library or
create your own custom view framework.



[_Return to Categories_](#categories)
